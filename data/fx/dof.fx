VertexShader = [[attribute vec3 pos;attribute vec4 col;attribute vec3 nor;attribute vec2 uv;uniform mat4 proj;uniform mat4 view;uniform mat4 world;varying vec2 vtx_uv;void main(){    gl_Position = vec4((pos+vec3(-0.5,-0.5,0))*2.0,1.0);    vtx_uv = pos.xy;}]]FragmentShader = [[uniform sampler2D color_tex; uniform vec4 scolor;uniform sampler2D srcBuf;uniform sampler2D srcBuf_depth;uniform vec4 size;uniform vec4 ep1;uniform vec4 ep2;uniform vec4 vparam;uniform vec4 time;varying HIGHP vec2 vtx_uv;varying vec2 coords[14];#define PI  3.14159265float width  = size.x; // screen widthfloat height = size.y; // screen heightvec2 texel = vec2(1.0/width,1.0/height);//uniform variables from external scriptfloat znear = vparam.x;//1.0; //camera clipping startfloat zfar = vparam.y;//1000.0; //camera clipping endfloat fov = vparam.z;float focalDepth = ep1.x;  //focal distance value in meters, but you may use autofocus option belowfloat focalLength = 0.050;//ep2.x;//1.0/ ep1.x;//cos(fov);//focal length in mmfloat fstop = pow(ep1.y,5.0);//*10.0; //f-stop valuebool showFocus = (ep2.w > 0.5); //show debug focus point and focal range (red = focal point, green = focal range)/* make sure that these two values are the same for your camera, otherwise distances will be wrong.*///------------------------------------------//user variablesint samples = 2; //samples on the first ringint rings = 8; //ring countfloat CoC = 0.03;//circle of confusion size in mm (35mm film = 0.03mm)float threshold = ep1.z*3.0; //highlight threshold;float gain = ep1.w*10.0; //highlight gain;float bias = 0.5; //bokeh edge biasfloat fringe = 1.0; //bokeh chromatic aberration/fringingbool noise = true; //use noise instead of pattern for sample dithering//------------------------------------------float hash( float n )	{	for(float i = 0.0; i < 5.0; i++){		n = fract(n * 1234.5678);	}	return fract( n );}//float l = hash(vtx_uv.x * vtx_uv.y * time.x);float penta(vec2 coords) //pentagonal shape{	float feather = 1.0; //pentagon shape feather	float scale = float(rings) - 1.3;	vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);	vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);	vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);	vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);	vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);	vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);		vec4  one = vec4( 1.0 );		vec4 P = vec4((coords),vec2(scale, scale)); 		vec4 dist = vec4(0.0);	float inorout = -4.0;		dist.x = dot( P, HS0 );	dist.y = dot( P, HS1 );	dist.z = dot( P, HS2 );	dist.w = dot( P, HS3 );		dist = smoothstep( -feather, feather, dist );		inorout += dot( dist, one );		dist.x = dot( P, HS4 );	dist.y = HS5.w - abs( P.z );		dist = smoothstep( -feather, feather, dist );	inorout += dist.x;		return clamp( inorout, 0.0, 1.0 );}vec3 color(vec2 coords,float blur) //processing the sample{	vec3 col = vec3(0.0);		col.r = texture2D(srcBuf,coords + vec2( 0.000, 1.0)*texel*fringe*blur).r;	col.g = texture2D(srcBuf,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;	col.b = texture2D(srcBuf,coords + vec2( 0.866,-0.5)*texel*fringe*blur).b;		vec3 lumcoeff = vec3(0.299,0.587,0.114);	float lum = dot(col.rgb, lumcoeff);	float thresh = max((lum - threshold)*gain, 0.0);	return col+mix(vec3(0.0),col,thresh*blur);}vec2 rand(vec2 coord) //generating noise/pattern texture for dithering{	float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;	float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;		if (noise)	{		noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;		noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;	}	return vec2(noiseX,noiseY);}float linearize(float depth){	return -zfar * znear / (depth * (zfar - znear) - zfar);}float vignette(){	float vignout = 1.3; //vignetting outer border	float vignin = 0.0; //vignetting inner border	float vignfade = 22.0; //f-stops till vignete fades	float dist = distance(gl_TexCoord[3].xy, vec2(0.5,0.5));	dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);	return clamp(dist,0.0,1.0);}void main() {	float depth = linearize(texture2D(srcBuf_depth,vtx_uv.xy).x);		//dof blur factor calculation		float blur = 0.0;		float f = (focalLength*2.0); //focal length (mm)	float d = linearize(focalDepth);//focalDepth; (REAL DEPTH) 	float o = depth; //depth in mm	float a = (o*f)/(o-f); 	float b = (d*f)/(d-f); 	float c = (d-f)/(d*fstop*CoC); 	blur = abs(a-b)*c*0.1;	blur = clamp(blur,0.0,1.5);		vec2 noise = rand(vtx_uv.xy)*blur * 0.0001;	// getting blur x and y step factor	float w = (1.0/width )*blur+noise.x;	float h = (1.0/height)*blur+noise.y;			vec3 col = texture2D(srcBuf, vtx_uv.xy).rgb;	float s = 1.0;	int ringsamples;		for (int i = 1; i <= rings; i += 1)	{   		ringsamples = i * samples;				for (int j = 0 ; j < ringsamples ; j += 1)   		{			float step = PI*2.0 / float(ringsamples);			float pw = (cos(float(j)*step)*float(i));			float ph = (sin(float(j)*step)*float(i));			float p = 1.0;						// penta			p = penta(vec2(pw,ph));			col += color(vtx_uv.xy + vec2(pw*w,ph*h),blur)*p *mix(1.0,(float(i))/(float(rings)),bias);  			s += 1.0*p *2.0*mix(1.0,(float(i))/(float(rings)),bias);						// noise			float lr = (hash(vtx_uv.x * vtx_uv.y * time.x+j*0.6) - 0.5) * 0.5;			float lg = (hash(vtx_uv.x * vtx_uv.y * time.x+j*0.7) - 0.5) * 0.5;			float lb = (hash(vtx_uv.x * vtx_uv.y * time.x+j*0.8) - 0.5) * 0.5;			col += vec3(lr,lg,lb);			}	}	col /= s; //divide by sample count	col *= vignette();		if (showFocus)		col = vec3(blur,blur,blur);	gl_FragColor.rgb = col;	gl_FragColor.a = 1.0;	}]]GeometryShader = ""DepthTest = false