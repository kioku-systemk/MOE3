VertexShader = [[attribute vec3 pos;attribute vec4 col;attribute vec3 nor;attribute vec2 uv;uniform mat4 proj;uniform mat4 view;uniform mat4 world;varying HIGHP vec2 vtx_uv;void main(void){	vtx_uv = pos.xy;	gl_Position = vec4((pos+vec3(-0.5,-0.5,0))*2.0,1.0);}]]FragmentShader = [[uniform sampler2D color_tex; uniform vec4 scolor;uniform sampler2D srcBuf;uniform sampler2D srcBuf_depth;uniform sampler2D colBuf;uniform sampler2D colBuf_depth;uniform vec4 size;uniform vec4 ep1;uniform vec4 znearfar;uniform mat4 proj;uniform mat4 view;varying HIGHP vec2 vtx_uv;const int maxCount = 64 * 4;const float PI = 3.1415926;float getFromDepthBuffer(float depthVal){	//return - znearfar.x * znearfar.y / (depthVal * (znearfar.y - znearfar.x) - znearfar.y); // Z val	float CF = log(znearfar.y + 1);	//return - znearfar.x * znearfar.y / (exp(depthVal * CF * 2.0) * (znearfar.y - znearfar.x) - znearfar.y); // Z val	return depthVal * znearfar.y - znearfar.x;}float tangent(vec3 p, vec3 s) {    return (p.z - s.z) / length(p.xy - s.xy);}void main(void){	vec3 normal = texture2D(srcBuf, vtx_uv).xyz;	vec3 depth = vec3(vtx_uv, getFromDepthBuffer(texture2D(srcBuf_depth, vtx_uv).x));	//normal.z = sqrt(1.0 - normal.x * normal.x  - normal.y * normal.y);		//depth.z *= 5.0;//gl_FragColor = vec4(normal,1.0);//return;	int cnt = 0;	vec4 sump = vec4(0);	float cs = cos(34.0/180.0*PI);	float sn = sin(34.0/180.0*PI);	mat2 mr = mat2(cs,-sn, sn,cs);	float rayScale = 1.0 + 0.1 / 4.0;	mat2 ms = mat2(rayScale, 0, 0, rayScale);	vec2 sv = vec2(1.0/size.x, 0.0);	float ao = 0.0;	for (int i = 0; i < maxCount; ++i) {		sv = ms * mr * sv;			vec2 sv1 = sv + normal.xy*0.2*0.01;		vec3 d1 = vec3(vtx_uv, getFromDepthBuffer(texture2D(srcBuf_depth, vtx_uv + sv1).x));		d1.xy *= 1.0 + 0.062*0.2;		float t1 = atan( tangent(depth, d1) );			vec2 sv2 = sv + normal.xy*0.2*0.01;				vec3 d2 = vec3(vtx_uv, getFromDepthBuffer(texture2D(srcBuf_depth, vtx_uv + sv2).x));		d2.xy *= 1.0 + 0.062*0.2;		float t2 = atan( tangent(depth, d2) );	             ao += clamp( (t1+t2) / PI, 0.0, 1.0 );	}	vec4 colorLight = texture2D(colBuf, vtx_uv);	vec3 dir = vec3((vtx_uv-vec2(0.5))*2.0, -getFromDepthBuffer(texture2D(srcBuf_depth, vtx_uv).x)*0.5);	dir = normalize(dir);	normal.z *= -1.0;//gl_FragColor = vec4(normal,1);//return;	// ref	vec4 refCol = vec4(1);	if (colorLight.w < 0.9) {		vec3 rdir = reflect(dir,normal);		//gl_FragColor = vec4((rdir+vec3(0.5))*.5, 1.0);		//return;		for (int t = 0; t < 500; ++t) {			vec2 step = vec2(0.0001*float(t));			vec2 sampUV = vtx_uv + rdir.xy*step;			if (sampUV.x < 0.0 || sampUV.x > 1.0) return;			if (sampUV.y < 0.0 || sampUV.y > 1.0) return;			vec3 d = vec3(vtx_uv, getFromDepthBuffer(texture2D(srcBuf_depth, sampUV).x));			if (d.z < depth.z && (d.z + .2) > depth.z) {				//gl_FragColor = vec4(0, t/100.0, 0, 1.0);				//return;				vec3 rcol = texture2D(colBuf, vtx_uv + rdir.xy*step).xyz;							refCol = vec4(rcol, 1.0);				break;			}		}	}	float r = 1.0 - ao / float(maxCount);		gl_FragColor = mix(vec4(r,r,r,1.0), vec4(1,1,1,1), colorLight.w) * vec4(colorLight.xyz, 1.0) * refCol;}]]GeometryShader = ""