VertexShader = [[attribute vec3 pos;attribute vec4 col;attribute vec3 nor;attribute vec2 uv;uniform sampler2D color_tex;uniform mat4 proj;uniform mat4 view;uniform mat4 world;uniform vec4 p1;varying HIGHP vec2 vtx_uv;varying HIGHP vec3 vtx_nor;varying LOWP vec4  vtx_col;void main(void){	vtx_uv = uv;	vtx_col = col;	vtx_nor = normalize(nor);	gl_Position = proj * view * world * vec4(pos,1);}]]FragmentShader = [[uniform vec4 time;varying HIGHP vec2 vtx_uv;varying LOWP vec4  vtx_col;varying HIGHP vec3 vtx_nor;#define LINES 8.0#define BRIGHTNESS 0.5const vec3 ORANGE = vec3(1.4, 0.8, 0.4);const vec3 BLUE = vec3(0.5, 0.9, 1.3);const vec3 GREEN = vec3(0.9, 1.4, 0.4);const vec3 RED = vec3(1.8, 0.4, 0.3);void main() {    float x, y, xpos, ypos;    float t = time.x * 10.0;    vec3 c = vec3(0.0);		vec3 N = normalize(vtx_nor);	xpos = N.z+time.x-1.0;    ypos = N.y*4.0+1.0;        x = xpos;    for (float i = 0.0; i < LINES; i += 1.0) {        for(float j = 0.0; j < 2.0; j += 1.0){            y = ypos            + (0.30 * sin(x * 1.000 +( i * 1.5 + j) * 0.4 + t * 0.050*i*j)            + 0.100 * cos(x * 6.350 + (i  + j) * 0.7 + t * 0.050 * j)            + 0.024 * sin(x * 12.35 + ( i + j * 4.0 ) * 0.6 + t * 0.034 * (8.0 * i* j))               );            			c += vec3(1.0 - pow(clamp(abs(1.0 - y) * 16.0 - 2.0*pow(time.x*0.2*vtx_uv.x, 3.0), 0.0, 1.0), 0.5));        }    }        c *= mix(             mix(ORANGE, BLUE, xpos*.5)             , mix(GREEN, RED, xpos*.5)             ,(sin(t * 0.02) + 1.0) * 0.45             ) * BRIGHTNESS;		vec3 bg = mix(vec3(0.8,0,0.3),vec3(0,0,0),vtx_nor.y*0.5+1.0-0.1*time.x);	float fadein  = min(0.25*time.x*time.x, 2.0)*0.5 ;	float fadeout = min(1.0, (max(time.x, 4.5) - 4.5)*3.0);	vec3 ocol = mix(mix(vec3(0,0,0), bg + c, fadein), vec3(1,1,1), fadeout);	gl_FragColor = vec4(ocol, 1.0);}]]GeometryShader = ""DepthTest = falseBlend = trueBlendSrc = "SRC_ALPAH"BlendDst = "ONE_MINUS_SRC_ALPHA"Priority=10